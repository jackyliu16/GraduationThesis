\section{设计结果论述与不足思考}

    指纹考勤系统以树莓派4B（BCM2711）为核心，包括以下组件：
    指纹传感器HLK-FPM383C、
    基于树莓派板载BCM54213PE PHY芯片的通信模块，
    以及由上位机提供的数据存储，日志记录的部分。\\

    \noindent 全文主要完成了以下六个方面的工作：

    \begin{itemize}
        \item 完成了指纹考勤系统整体设计，对于一个最简易的单片机指纹考勤系统进行了需求分析。
        \item 完成了指纹考勤系统硬件电路设计。主要包括主控模块与信号回返模块，串口输入模块之间的硬件电路设计。
        \item 在组件化操作系统 ArceOS 上仿照树莓派官方 linux 内核中驱动相关实现，实现并整合了一个能运行的以太网驱动，
            该驱动实现了以太网物理层与数据链路层之间的通信，
            嵌入式裸机应用程序可以深度集成到ArceOS中，调用由 ArceOS 实现的 Tcp/Udp 以太网协议栈以在应用层面调用 UdpSocket 所提供的服务编译成一个完整的单一用途裸机应用程序。
            通过这个以太网驱动，可以实现下位机与上位机之间的以太网帧通信\ref{fig::树莓派通信正常}。
        \item 将上述以太网驱动与 ArceOS 中提供上层网络包装的 axnet module\footnote{基于smlotcp的实现} 进行结合，
            实现了基于 UdpSocket 的发包功能。
        \item 在组件化操作系统 ArceOS 中，基于自建 UART 串口驱动与FPM383模组通信协议\cite{noauthor_fpm383c_nodate}，
            实现了 ArceOS 的指纹模块，能基于串口信号传输，实现简单的如LED亮灯，要求FPM383C模块进行指纹匹配，
            对于收到的指纹匹配结果进行分析等功能。
        \item 根据上述指纹考勤系统设计需求，实现了一个基于 ArceOS 改写标准库的裸机应用程序。
    \end{itemize}

    \noindent 实现的不足之处：

    \begin{itemize}
        \item 参照树莓派 linux 内核中以太网卡实现的部分操作还没有调通，从 BCM54213PE PHY 芯片所返回的状态检查一直
        显示当前链路状态未建立，查阅了全部可能有关的状态寄存器，仍然无法明确具体这种情况是由什么原因导致的。
        幸运的是，在深入研究时我发现了一个名为 rpi4-rust-workspace 的代码仓库 \cite{rpi4-rust-workspace}，
        在这个最后更新于 20 年的仓库中提供了一个相较于我实现更为完善的以太网卡驱动，只不过由于仓库维护者太久没有进行维护，
        在仓库中所引用的很多 rust 语言的方法没有办法在 ArceOS 所支持的 rust 工具链中正常运行。
        同时，仓库中也存在着很多由于维护者直接将 rpi3 版本中寄存器复制到 rpi4 版本的过程中没有详细检查寄存器等调用是否一致所导致的问题，
        比如说在 UART 驱动实现所牵涉到的 GPIO 部分\footnote{根据 FPM383C 模块说明，必须要在Rx设定上拉电阻}，维护者直接将在
        rpi3(bcm2835) 使用的 GPIO Pull-up/down Register 也就是 GPPUD 寄存器等寄存器规约复制到了 rpi4(bcm2711)
        中\cite{raspberry-pi-bcm2835}。但是，树莓派 4 中采用了另外的一组寄存器 GPIO\_PUP\_PDN\_CNTRL\_REG0 来控制上拉下拉电阻
        \cite{raspberry-pi-bcm2711}，二者类型不同，起始地址也不同。
        亦或是由于作者实现串口驱动的目的在于通过串口反馈简单字符串，并没有考虑到在大信息通量下的数据获取问题，因此没有启用 FIFO 等。
        \item 由于时间因素的影响，并没有如同前面设计的那样，实现了多种不同的上位机，下位机通讯机制，只完成了基于 BCM54213PE 板载
        PHY 芯片的网络通信机制实现。
        \item 在实现树莓派经由 BCM54213PE PHY 芯片与上位机进行通信的时候，由于时间因素的影响
        \footnote{就目前来看可能还需要 4 天以上的工作量}，
        未能详细的对于 ArceOS 内部实现以太网协议栈的部分进行详细分析，因此在树莓派中接受网络包的时候仍存在一定问题，
        在实现指纹注册并下发的工况中
        \footnote{上位机中 python 后端程序调用串口，从上位机从属指纹识别模块获取指纹特征信息，并将对应指纹特征信息下发到树莓派从属指纹识别模块中}
        树莓派上所运行的应用程序没有办法正常通过 ArceOS 提供的 UdpSocket 中收到对应数据包
        \footnote{但是可以直接收对应的以太网帧，以太网帧的数据可以被正确接收，理论上可以直接越过 UDP 包头强行实现后面的内容，
        所以这个部分只能算缺陷}。

        具体问题应该出在对于 module::axnet 与 BCM54213PE 驱动在 crates::driver\_net 兼容层中的实现上。
        根据目前 BCM54213PE 驱动的实现，任何通过以太网接口发送到树莓派 4B 设备上的信息，都会由树莓派内部的 dma 控制器自动
        存储到 BCM54213PE 驱动内部的缓存空间 tx/rx\_mem，也就是前文 \ref{pict:DmaDescAndLoop} 所提到的 DMA 环
        中各个 Description 所指向的缓存空间 \footnote{[0u8; 0x2000] 的 buffer}。
        实际上我们直接调用由 BCM54213PE 驱动提供的 receive 功能相当于从
        已经写入的 Buffer 中返回一个指向 tx/rx Buffer 的引用\footnote{循环链表，通过指针指向下一个需要读取的位置}，
        而并非类似于我在 FPM383C 驱动中实现的那种阻塞，等待收到一个网络包后再返回的情况
        \footnote{由于在与 FPM383C 驱动通信的情况下，只要发送的数据包格式正确，一定能收到对应的应答包，因此才可以使用阻塞的办法，
        此处由于不能确定什么时候上位机向下位机传输数据，因此不能直接采取阻塞的办法}。

        但是，ArceOS 内部基于 smoltcp 的以太网协议栈中通过 Tx/RxToken 这种用过即毁的 traits，提供的类似 Drop 方法，
        要求我们在实现这个部分的时候，手动实现 alloc\_tx\_buffer, recycle\_tx/rx\_buffer 的方法，这与我们目前的
        receive 操作流程不符。如果说直接将其嵌入到我们现有的 BCM54213PE 驱动中，还需要面临一系列的寄存器设置的问题，
        可能需要等后期进一步实现才能完善这个部分的内容。

        \item 在实现驱动的过程中面临着比较多的问题，同时由于 BCM54213PE 属于一种专有化的驱动，
        并不如同 ENC28J60 一样常见，可能缺乏普遍性。
        比如说由于 BCM54213PE 这款 PHY 芯片对应的底层信息尚未开源，无法通过查阅手册的方式
        \footnote{目前只找到了基础 MDIO 通信手册，有且仅对调试过程提供了支持}
        解决开发过程中遇到的比如说链路状态未正常建立的问题。同时，由于转写的时候不了解具体实现细节，大量的代码均依照树莓派 linux
        内核内部宏定义通过类似于宏的 Rust 硬件抽象实现。在这种情况下，大量寄存器的操作是通过对绝对地址进行 volatile 读写方式实现的，
        可能在其他开发板上进行复用的时候会面临一定程度上的困难。
    \end{itemize}