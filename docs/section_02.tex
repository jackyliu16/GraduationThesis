\section{系统设计}

\subsection{需求分析与模块选型}

\subsubsection{系统功能需求分析}

根据一般企事业单位对于考勤事务的管理规范，本指纹考勤系统需要实现以下几种功能，通过上位机对于下位机中指纹识别模块保存的指纹信息进行注册与删除，下位机基于前者提供的指纹数据实现基于光学识别的指纹打开签到功能。

\subsubsection{系统方案设计与选型}

根据上述系统功能需求，以树莓派4B所提供的 bcm2711 作为中央处理芯片，指纹考勤系统主要由电源供电模块，声音反馈模块，USB转TTL串口通信模块，网卡模块。
系统总体设计方案如图2.1所示。

% https://www.processon.com/v/65ec0156778cc21034664557
\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth]{imgs/总体设计图.png}
    \caption{总体设计图}    \label{overall_design}
\end{figure}

\subsubsection{嵌入式开发板选型}

树莓派4B\ref{树莓派硬件配置说明图}使用的 bcm2711 是一种四核心64位ARM Cortex-A72架构CPU，主频高，能满足多种复杂计算需求以及满足大型程序运行需求。
树莓派4B还存在丰富而完善的接口，两个USb3.0接口，两个USB2.0接口，一个千兆网卡接口，一个HDMI接口，一个CSI接口和一个DSI接口，能够满足对于各种外设的连接需求。
树莓派4B还是树莓派第一个支持不通过 usb 直接访问网卡芯片实现网卡介入的开发板，这无形之中对于实现板载网卡驱动提供了很多帮助。

\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth]{imgs/树莓派硬件配置说明图.png}
    \caption{树莓派硬件配置说明图}    \label{树莓派硬件配置说明图}
\end{figure}

\subsubsection{指纹识别模块选型}

FPM383F识别指纹模块功耗低半导体面阵传感器是一款低功耗的光学指纹识别模块，
支持对于60组光学指纹进行存储，其通过串口与中央处理器进行通信，
在串口驱动方面，基于树莓派底层寄存器UART进行调用完成对应信息的发送难度不高。

根据模组规格书，指纹模块在上电之后需要保持至少 180ms 等待才可以正常进行通信，VCC在下电之前要求设置 MCU 串口为输入高阻态，Rx 需要添加上拉电阻等需求，相对较为容易满足。

\begin{figure}[ht]
    \centering
    \includegraphics[scale=0.6]{imgs/FPM383C串口设备图.png}
    \caption{FPM383C串口设备图}    \label{FPM383C串口设备图}
\end{figure}


\subsubsection{通信模块选型}

    基于一般企事业单位对于考勤签到需求的需求，我计划提供多种不同的通信模块实现方便选用单位进行选择，
    其中传统基于 CH304 串口转 TTL 通信模块实现的简单串口通信主要适用于仅对于一两台设备进行支持的情况，
    而基于网卡模块间接通过网络方式拓展下位机数量的方式是主要计划实现的支持。
    针对于不同的预算管理需求，计划采用两种不同的方式实现网卡驱动，
    一种是基于 raspberry4B 板载 bcm54213PE 网卡芯片的驱动，
    另一种是基于 ENC28J60，一种基于 SPI 连接的外置 10BASE-T 以太网连接模块实现的。
    但是目前只实现了基于 BCM54213PE 网卡芯片驱动的支持。

\subsection{硬件设计}

    由于本实现相对来说比较轻量化，不太需要外部模块的支持\ref{外部模块接线图}，因此只通过杜邦线进行连接，并没有画对应的板子。

    \begin{figure}[ht]
    \centering
    \includegraphics[scale=0.6]{imgs/接线图.png}
    \caption{外部模块接线说明图}    \label{外部模块接线图}
    \end{figure}

    \begin{itemize}
        \item 信号回返模块：
            本模块主要实现的功能在基于树莓派电信号输出，实现简单的蜂鸣功能以提醒用户当前进行的打卡已经被正确识别。
            目前有两种实现的方法，一种是基于三极管实现的长延时信号灯，另外一种是基于无源蜂鸣器实现的。
        \item 指纹采集模块：
            本模块使用了现成的串口通信指纹识别模块予以完成。
        \item 网络通信模块：
            本模块主要使用了现有的树莓派板载 PHY 芯片 BCM54213PE 实现了对应的功能，同时
            还提供了串口替代的 USB 通信方法。
    \end{itemize}

\subsection{软件设计}

    由于本研究所采用的基础嵌入式应用程序所面对的的嵌入式应用场景相对较为单一，同时也是单应用程序单地址空间的。
    \footnote{虽然底层操作系统支持使用页表进行隔离，但是在应用层面上并没有使用到虚拟页表，只是在boot的时候使用了内核页表}
    因此整体软件设计相对较为简单，主要实现难度在驱动设计层面体现，具体内容与开发过程在第三章中进行呈现。
    在嵌入式应用层面只通过循环读取 UART 串口设备驱动反馈的数据，将其分析之后的结果通过由 ArceOS 包装底层以太网驱动实现的
    UDP 包经由 RJ-45 向上位机中运行的简单管理应用程序中发送。

    在上位机中通过简易的 python 客户端程序，对于嵌入式设备中传输的 UDP 包进行分析，实现基于 Sqlite 数据库的简单指纹信息 CRUD，打卡数据 CRUD，
    与一个基于命令行实现的打卡记录查询与导出应用程序。

    \subsubsection{嵌入式软件设计}

    参照一般嵌入式考勤打卡设备的标准结构，我设计的嵌入式应用在完成对应变量初始化之后维持在一个主循环中运行。
    一次循环包括收网络包\footnote{匹配帧头后向指纹模块下发对应UART包实现下载，删除指纹特征的效果}
    ，执行指纹匹配命令，对于指纹匹配结果进行查询，并在完成匹配时通过网络向上位机以特定的帧形式发送网络包告知其
    已经收到用户的打卡信息。

    \begin{algorithm}[H]
        \caption{嵌入式设备主循环}
        \label{algorithm::fingerprint_network_comm}
        \begin{algorithmic}[1]
        \While{true} \Comment{嵌入式设备主循环事件}
            % \State \textbf{try} \Call{ReceiveData}{$socket, \& buf$}
            \If{\Call{Receive}{$socket, \& buf$} = Ok$(size, addr)$} \Comment{收到了网络包}
                \If{收包结果与特定帧头匹配}
                    \State 将对应 UART 帧转发给从属指纹识别模块
                \EndIf
                \State $buf \gets [0; 1024]$ \Comment{重置缓冲区}
            \ElsIf{\textbf{error} = WouldBlock}
                \State \textbf{continue} \Comment{如果资源忙，忽略并继续}
            \Else
                \State \Call{LogDebug}{\textbf{error}} \Comment{打印其他错误}
            \EndIf
        
            \State \Call{Write}{serial, \text{search\_fingerprint\_match\_pattern}} \Comment{向设备发送匹配命令}

            \State \Call{Delay}{10} \Comment{等待模块进行指纹匹配}
            \State \Call{GetFrame}{$serial$} \Comment{处理返回帧}
            
            \State \Call{Write}{serial, \text{check\_match\_\_result\_pattern}} \Comment{向设备发送匹配命令}
        
            \If{$frame \gets$ \Call{GetFrame}{$serial$}}  \Comment{对于返回包进行分析}
                \State \Call{Assert}{$frame$, CmdType::CheckMatchFingerprint} \Comment{确保应答包一致}
                
                \If{\Call{Any}{$data, \neq 0$}}
                    \State \textbf{initialize} $sign\_in\_buf \gets [0x46, 0x69, \ldots, 0x20]$ \Comment{网络包}
                    \State \Call{SetSignInData}{$frame, sign\_in\_buf$} \Comment{根据应答包设置 buf 中与ID部分}
                    \State \Call{SendTo}{$local\_socket, sign\_in\_buf, target\_socket$}
                    \State \Call{Write}{serial, \text{green\_flashing\_pattern}} \Comment{向设备发送绿灯闪烁}
                \EndIf
                \State \Call{GetFrame}{$serial$}
            \EndIf
        \EndWhile
        \end{algorithmic}
        \end{algorithm}
        

    \subsubsection{数据库设计}

    由于对应本次嵌入式设计的上位机中的操作需求相对较为简单直白。同时，不同于课堂考勤系统等需要额外的提供很多
    诸如教学班，教室，教师表的需求，本次嵌入式软件在功能层面仅需要完成简单的考勤打卡记录，指纹特征模块的存储
    的功能，因此在表实现上仅需要维持三个表的存在，分别是指纹特征表，员工信息表，考勤打卡表。

    因此，在这样的一个简单的的嵌入式项目中使用诸如 Oracle, MySQL, PostgreSQL 等大型企业级数据库是没有效率
    的行为，在设计中综合考量了一系列如 SQLite， LMDB 等嵌入式常用的数据库，考虑到常用性，库支持程度等因素之后
    选用了 SQLite 作为嵌入式信息存储的数据库。

    \begin{description}
        \item[用户信息表] 存储常见的用户信息数据

            在用户信息表\ref{tab:userInfo}中完成对于用户ID，指纹特征信息的存储属于一种最基本的考勤系统嵌入式设计需求。在本表中我将 user\_id 作为主键，唯一性的声明用户的身份，并且将其与唯一对应的指纹信息进行关联，在还引入了指纹特征表的主键 finger\_print\_id 实现级联删除。

            同时，考量到在实际上位机将对应数据下载到嵌入式设备的从属指纹识别模块的时候需要先向
            其发送一个 指纹特征信息下载 包，在该包中声明本次传输的信息会被装载到哪个指纹特征ID以及传输的指纹特征数据长度，以方便指纹模块根据长度截断数据。在本表中还专门提供了与
            finger\_print\_id 对应的长度数据。

            \begin{lstlisting}[language=SQL
                , caption={用户信息表}
                , label = {tab:userInfo}
                , breaklines=true
                , breakatwhitespace=true]
CREATE TABLE IF NOT EXISTS user (
    user_id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_name TEXT NOT NULL,
    finger_print_id INTEGER,
    finger_print_len INTEGER,
    other_message TEXT,
    FOREIGN KEY (finger_print_id) REFERENCES fingerPrint(finger_print_id)
);
            \end{lstlisting}

        \item[指纹特征表] 存储指纹 ID，指纹特征长度，指纹特征信息等内容。
        
            在指纹特征表\ref{tab:fingerprintInfo}中存储了对应于指纹ID的 frame 号，总数据长度，二进制指纹信息的内容。
            其中没有如一般操作那样采用指纹ID作为主键，主要是考量到在实际进行发送的时候采用的是分段发送方法，即每次向指纹模块传输数据的时候，除最后一个包外只发送128位长度的指纹特征数据。先在上位机中对于对应指纹特征信息进行组合，然后再存储到 SQLite 中，不仅会导致对于上位机更高的资源占用\footnote{在SQLite中以页的信息存储对应数据}，在实际将特征数据下载到嵌入式设备的从属指纹识别模块的时候同样需要进行切分之后再发送，无疑是增添了许多无异议的工作量，因此最终并没有采用这种形式存储指纹特征数据。而是根据对应对应二进制数据由指纹模块上传到上位机中自带有的 frame 号 对逐帧的数据进行简单的分割。

            \begin{lstlisting}[language=SQL
                , caption={指纹特征表}
                , label = {tab:fingerprintInfo}
                , breaklines=true
                , breakatwhitespace=true]
CREATE TABLE IF NOT EXISTS fingerPrint (
    id INTEGER,
    frame INTEGER,
    data BLOB NOT NULL,
);
            \end{lstlisting}          


        \item[考勤打卡表] 记录考勤打卡的时间信息
        
            在考勤打卡表\ref{tab:signIn}中主要保存对应于 user\_id 的打卡数据，其中通过默认CURRENT\_TIMESTAMP的方式自动插入了对应的时间戳数据，方便用户进行插入操作。

            \begin{lstlisting}[language=SQL
                , caption={考勤打卡表}
                , label = {tab:signIn}
                , breaklines=true
                , breakatwhitespace=true]
CREATE TABLE IF NOT EXISTS signIn (
    user_id INTEGER,
    time TEXT DEFAULT CURRENT_TIMESTAMP
)
            \end{lstlisting}    

    \end{description}

    \subsubsection{功能说明}

    \begin{description}
        \item[指纹注册] 由上位机中自动完成指纹注册，通过上传命令，获取对应ID的指纹特征信息并以UDP包的形式下发到下位机中的指纹模块。
        
        指纹注册功能主要在上位机中完成，这主要是考量到在 HR 处实现人事登记等操作
        更加合乎一般企业的考勤流程。
        
        通过 0x0118 命令\ref{uart::auto-register}，实现自动注册功能，该命令会自动完成采图、提取、拼接、保存等操作，
        该部分通过分析返回包中的ID和注册进度进行操作，在注册进度达到 0x64 时终止注册流程。

        \begin{table}[htbp]
            \resizebox{\textwidth}{!}{%
                \begin{tabular}{|l|l|l|l|l|l|l|l|}
                \hline
                \multicolumn{1}{|c|}{校验密码} & CMD类型 & CMD号 & 等待手指 & 按压次数 & ID\_H & ID\_L & 校验和  \\ \hline
                0x00 0x00 0x00 0x00        & 0x01  & 0x18 & 0x01 & 0x06 & 0xFF  & 0xFF  & 0xE2 \\ \hline
                \end{tabular}
            }
            \caption{自动注册命令用户层帧} \label{uart::auto-register}
        \end{table}

        在注册完成之后，通过上载命令\ref{uart::upload-info}，向指纹模块获取特定 ID 号的指纹特征信息长度，
        然后再通过 \ref{uart::upload-data} 命令，从指纹模块获取对应分片的指纹特征信息。
        在将信息存储到数据库的同时，还通过 UDP 包的形式，将对应的数据发送到树莓派，树莓派再将对应指纹特征信息
        下载到树莓派对应的指纹模块上，由此完成了一次标准的指纹注册功能。

        \begin{table}[htbp]
            \resizebox{\textwidth}{!}{%
                \begin{tabular}{|l|l|l|l|l|l|}
                \hline
                \multicolumn{1}{|c|}{校验密码} & CMD类型 & CMD号 & ID\_H & ID\_L & 校验和  \\ \hline
                0x00 0x00 0x00 0x00        & 0x01  & 0x53 & 0x00  & 0x01  & 0xAB \\ \hline
                \end{tabular}
            } \caption{获取上传信息命令用户层帧} \label{uart::upload-info}
        \end{table}

        \begin{table}[htbp]
            \resizebox{\textwidth}{!}{%
            \begin{tabular}{|l|l|l|l|l|l|l|l|}
                \hline
                \multicolumn{1}{|c|}{校验密码} & CMD类型 & CMD号 & ID\_H & ID\_L & NUM\_H & NUM\_L & 校验和  \\ \hline
                0x00 0x00 0x00 0x00        & 0x01  & 0x51 & 0xFF  & 0xFF  & 0x00   & 0x00   & 0xAC \\ \hline
                \end{tabular}
            } \caption{获取指纹特征命令用户层帧} \label{uart::upload-data}
        \end{table}

        \item[指纹删除] 在上位机中完成指纹删除操作，通过下行 Udp 包，删除指纹模块中对应 ID 的指纹特征信息。
        
        指纹删除功能主要在上位机中完成，在出现指纹出现问题的时候，由 HR 执行运行函数，自动化删除数据库中员工对应的指纹特征编号，
        同时将删除指纹特征编号的命令通过下面的指令\ref{指纹特征清除}经由树莓派下发到指纹终端，根据不同的需求，在下面的帧中配置不同的格式。

        \begin{table}[ht]
            \resizebox{\textwidth}{!}{%
                \begin{tabular}{|l|l|l|l|l|l|l|}
                \hline
                \multicolumn{1}{|c|}{校验密码} & CMD类型 & CMD号 & CL\_FLAG & ID\_H & ID\_L & 校验和  \\ \hline
                0x00 0x00 0x00 0x00        & 0x01  & 0x51 & 03       & 0xFF  & 0xFF  & 0xAC \\ \hline
                \end{tabular} 
            } \caption{指纹特征清除} \label{指纹特征清除}
        \end{table}

        \item[指纹考勤登记] 在下位机从属指纹模块中完成基于指纹的考勤实现。
        
        下位机会循环的向指纹模块询问指纹能否匹配\ref{询问是否匹配}，并按照匹配应答包\ref{匹配应答包}格式返回对应结果，
        根据对应的匹配分数以及是否完成匹配。

        当当前指纹被实际判断匹配成功，对应的数据就会被放在下面的帧结构中，再通过 UdpSocket 发送到上位机的 Socket，
        上位机中利用 Python Socket 对于 5555 端口进行长期监听，对所有监听到的数据包进行匹配，当前后帧结构一致的情况下
        将其中包含的 ID 按照 sqlite 的规定插入到对应表中
        \footnote{sqlite中有一种名为 CURRENT\_TIMESTAMP 的默认属性，会默认将插入项的时间作为一个元素一起插入}。

        \begin{table}[ht]
            \resizebox{\textwidth}{!}{%
                \begin{tabular}{|l|l|l|l|}
                \hline
                \multicolumn{1}{|c|}{校验密码} & CMD类型 & CMD号    & 校验和  \\ \hline
                0x00 0x00 0x00 0x00        & 0x01  & 0x21 / 0x22 & 0xAC \\ \hline
                \end{tabular}
            }  \caption{询问是否匹配，查询匹配结果} \label{询问是否匹配}
        \end{table}

        \begin{table}[ht]
            \resizebox{\textwidth}{!}{%
                \begin{tabular}{|l|l|l|l|l|l|l|l|}
                \hline
                \multicolumn{1}{|c|}{校验密码} & CMD类型 & CMD号 & 错误码                 & 匹配结果      & 匹配分数      & 匹配ID      & 校验和  \\ \hline
                0 0 0 0        & 0x01  & 0x51 & 0 0 0 0 & 0x00 0x01 & 0x27 0x0F & 0x00 0x03 & 0xAC \\ \hline
                \end{tabular} 
            }  \caption{匹配应答包格式} \label{匹配应答包}
        \end{table}

        \newpage
        \item[考勤记录读取] 根据一般企事业单位的考勤系统的历史发展来看，读取员工考勤记录属于考勤系统的必备功能。
        
        本功能主要实现在上位机处，由上位机调用函数对于原先保存在sqlite中的考勤打卡表与员工-指纹特征对应表进行自动关联，并且
        基于一定的逻辑分析打印出员工的详细打卡数据与月度打卡数据。
    \end{description}
      

