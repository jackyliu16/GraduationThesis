\section{总结与展望}

    \subsection{设计主要成果}

    本文基于组件化操作系统 ArceOS 提供了一种考勤系统的精简解决方案，系统基于指纹识别技术与
    以太网通信技术，根据指纹的唯一性保证，和 Rust 语言，组件化操作系统提供的安全性保障，实现了
    指纹考勤系统。

    该系统采用 Raspberry 开源基金会的 Raspberry Pi 4B 开发板（bcm2711）。
    指纹模块采用海凌科公司提供的 FPM383C 指纹识别模块，该模块采用面阵式指纹传感器识别技术，
    可以存储最多 60 枚指纹特征，采集高效，效果良好。
    以太网通信模块直接采用树莓派开发板板载 BCM54213PE PHY 芯片。

    该系统是基于指纹考勤系统的最小子集进行设计的，其中包括所有指纹考勤系统必要的组件，可以
    实现指纹匹配及联网考勤打卡统计，指纹特征信息注册及同步等功能。
    下位机应用程序在 NixOS flake 开发环境下编程实现，实现了简单循环指纹匹配发送匹配结果，并根据接收到的数据下载指纹特征的效果。
    上位机控制程序在 NixOS flake 开发环境下编程实现，实现了对于考勤信息的读取，入库，人员资料，
    考勤信息的管理。

    \noindent \textbf{全文主要完成了以下四个方面的工作：}

    \begin{enumerate}
        \item \textbf{完成了指纹考勤系统硬件电路设计} \\
        主要包括主控模块与信号回返模块，串口输入模块之间的硬件电路设计。
        \item \textbf{将 BCM54213PE linux 驱动移植到 ArceOS} \\
        在组件化操作系统 ArceOS 上仿照树莓派官方 linux 内核中驱动相关实现，实现并整合了一个能运行的以太网驱动，
        该驱动实现了以太网物理层与数据链路层之间的通信（如图\ref{fig::树莓派通信正常}所示）。
        在本次设计中我根据对于 ArceOS 中基于 smoltcp 实现的以太网协议栈封装（axnet）和 BCM54213PE 网卡驱动实现之间的分析，通过修改二者内容和
        满足接口需求的方法，将由 BCM54213PE 网卡驱动实现的以太网帧收发功能与以太网协议栈结合到一起，最终使应用层
        程序在调用 axstd 间接调用 UdpSocket 收发网络包时能如同在一般 x86\_64 linux rust std 开发环境中收发包类似的效果（如测试所示）。
        \item \textbf{基于 FPM383C 通信协议实现串口驱动} \\
        在组件化操作系统 ArceOS 中，基于自建 UART 串口驱动与 FPM383 模组通信协议 \cite{fpm383c-modular-communication-protocol}，
            实现了 ArceOS 的指纹模块，能基于串口信号传输，实现简单的如LED亮灯，要求FPM383C模块进行指纹匹配，
            对于收到的指纹匹配结果进行分析等功能。
        \item \textbf{完成了指纹考勤系统整体设计} \\ 
        完成了一个嵌入式指纹考勤系统的最小设计，该设计包含企事业单位所使用的考勤打卡系统常用的所有功能，
        如经由网络实现的指纹打卡信息记录与指纹特征信息联网同步增删改查，外加上位机中用户信息增删改查
        ，考勤信息按需求读取，导出csv文件等功能。
    \end{enumerate}

    \subsection{研究不足之处}

    \begin{enumerate}
        \item 自己实现的参照树莓派 linux 内核中以太网卡实现的部分操作还没有调通，
        从 BCM54213PE PHY 芯片所返回的状态检查一直显示当前链路状态未建立，
        查阅了全部可能有关的状态寄存器，仍然无法明确具体这种情况是由什么原因导致的。
        幸运的是，在深入研究时我发现了一个名为 rpi4-rust-workspace 的代码仓库 \cite{rpi4-rust-workspace}，
        在这个最后更新于 20 年的仓库中提供了一个相较于我实现更为完善的以太网卡驱动，只不过由于仓库维护者太久没有进行维护，
        在仓库中所引用的很多 rust 语言的方法没有办法在 ArceOS 所支持的 rust 工具链中正常运行。
        同时，仓库中也存在着很多由于维护者直接将 rpi3 版本中寄存器复制到 rpi4 版本的过程中没有详细检查寄存器等调用是否一致所导致的问题，
        比如说在 UART 驱动实现所牵涉到的 GPIO 部分\footnote{根据 FPM383C 模块说明，必须要在Rx设定上拉电阻}，维护者直接将在
        rpi3(bcm2835) 使用的 GPIO Pull-up/down Register 也就是 GPPUD 寄存器等寄存器规约复制到了 rpi4(bcm2711)
        中\cite{raspberry-pi-bcm2835}。但是，树莓派 4 中采用了另外的一组寄存器 GPIO\_PUP\_PDN\_CNTRL\_REG0 来控制上拉下拉电阻
        \cite{raspberry-pi-bcm2711}，二者类型不同，起始地址也不同。
        亦或是由于作者实现串口驱动的目的在于通过串口反馈简单字符串，并没有考虑到在大信息通量下的数据获取问题，因此没有启用 FIFO 等。

        \item 由于时间因素的影响，并没有如同前面设计的那样，实现了多种不同的上位机，下位机通讯机制，只完成了基于 BCM54213PE 板载
        PHY 芯片的网络通信机制实现。

        \item 在实现树莓派经由 BCM54213PE PHY 芯片与上位机进行通信的时候，由于时间因素的影响
        未能详细的对于 ArceOS 内部实现以太网协议栈的部分进行详细分析，因此在树莓派中接受网络包的时候仍存在一定问题，
        在高网络负载情况下会产生 panic，系统的抗风险能力存在一定问题。
        \footnote{虽然对于这个系统而言，无论进行什么操作都不可能达到那么大的负载}。

        \item 在实现驱动并尝试根据 ArceOS 设计理念进行复用的过程中面临着比较多的问题，
        同时由于 BCM54213PE 属于一种专有化的驱动，并不如同 ENC28J60 一样常见，缺乏普遍性，基本只能在树莓派 4B 上使用。
        又比如说由于 BCM54213PE 这款 PHY 芯片对应的底层信息尚未开源，无法通过查阅手册的方式
        \footnote{目前只找到了基础 MDIO 通信手册，有且仅对调试过程提供了支持}
        解决开发过程中遇到的比如说链路状态未正常建立，或者是 DMA 手动添加项目的问题。
        同时，由于转写的时候不了解具体实现细节，大量的代码均依照树莓派 linux 内核内部宏定义通过类似于宏的 Rust 硬件抽象实现。
        在这种情况下，大量寄存器的操作是通过对绝对地址进行 volatile 读写方式实现的，可能在其他开发板上进行复用的时候会面临一定程度上的困难。

        \item 在实现 FPM383C 串口传输驱动的时候，采用的算法是阻塞的（类似于 std 中以太网 socket 阻塞模式），
            会持续阻塞线程直到收到一个完整的 FPM383C UART 帧，但是当 FPM383C 与 Soc 之间的连接由于外界因素影响
            产生了断开或者丢失包的情况，就会导致程序死循环。而在循环中不存在所谓的命令重发机制，这会导致
            考勤系统客户端（树莓派）需要手动重启。虽然这种可能性不大，在整个测试过程中没有出现过，但是属于某种程度上的程序漏洞。
        
        \item ArceOS 和 Rust 高级程序语言提供的安全性保障其实更加倾向于使嵌入式设备不容易收到外界入侵或者控制影响上，
            但是这对常见的基于以太网的攻击，如 ARP 欺骗等无效。

        \item 在进行测试的时候，由于脚本使用的是 non blocking 的 C 套接字，因此
            测试时间完成之后，设备还需要收到一个以太网帧才会判断当前时间差是否超过测试时间，
            在测试中直接采用再运行一遍脚本实现这个效果，这可能导致在密集测试中无法很好的控制
            测试间断时间内网络包的发送（在网卡驱动缓冲区内的堆积情况）
            \footnote{虽然在收包的时候采用了收到指定以太网帧十秒之内收到的包总数进行测试}。
        % \item 在补充测试的时候，发现测试脚本存在缺陷，Linux 树莓派重复测试中发现丢包结果与实际 wireshark 收报结果不一致
        % （但是之前测试脚本测试的时候，丢包确实与 wireshark 丢包一致），怀疑此处测试脚本测出的丢包结果与 wireshark 结果不一致是由于
        % 单线程的测试脚本不能很好的实现收报导致的，但由于时间因素的影响，尚不能对此进行更加充分的测试。

    \end{enumerate}

    \subsection{工作展望}

    本次毕业设计中实现的 BCM54213PE 以太网卡驱动和 FPM383C 串口驱动均可以直接在树莓派 4B中进行复用，
    在完成提交记录清理等一系列后期工作及测试之后会被提交到 ArceOS 主仓库中，预计在后续操作系统树莓派支持上
    作为一个基础驱动被引入。

    通过对于本课题的研究，我对嵌入式系统开发有了比较深刻的理解和认识，虽然指纹考勤打卡系统的设计顺利完成且达到预期效果，
    但由于时间因素，整个系统的设计还存在不足之处，还可以进行进一步改进和完善，今后的改进可以从以下几个方面考虑：

    \begin{enumerate}
        \item \textbf{提供更多生物识别模块驱动支持：} 引入如虹膜，声音，射频卡 RFID 等技术进行考勤打卡，
        \item \textbf{技术下放：} 如同整个设计最开始的那样，由树莓派4B上实现简单指纹考勤系统开始，
        逐步降低所使用的开发板级别\footnote{当前采用的树莓派作为指纹考勤系统主控完全没有性价比}，
        使用如 Raspberry Pico(RP2040)，Arduino，stm32f103等相对较为便宜的开发板，甚至最后直接在 MCU 中运行
        应用程序。通过逐层降级开发板，以更好的利用 ArceOS 组件化操作系统的优势
        \footnote{ArceOS组件化操作系统实现的完整指纹考勤打卡系统二进制文件仅有 200kb 左右，而在嵌入式板子
        上运行的 linux 在剪枝之后的大小仍超过 2MB}。
        \item \textbf{对比不同操作系统中同等实现的性能和实用性：}
        在 RTThread，RT-Linux 等常见嵌入式操作系统中复现整个指纹考勤系统，并且就两次实现之间的性能等差异信息进行对比。
        
    \end{enumerate}