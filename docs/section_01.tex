\section{绪论}

\subsection{项目背景及意义}

    近年来，计算机网络安全事件频发，引起对操作系统安全性的高度关注。
    从2017年Windows操作系统中的“永恒之蓝”病毒到最近Linux操作系统中的开源软件XZ源供应链投毒事件及伊朗核试验基地遭受“震网”病毒袭击，
    这些事件凸显了操作系统安全性的重要性。
    操作系统作为国民生产和科研的关键组成部分，其安全性问题一旦受到威胁，不仅会导致个人隐私数据泄露，
    还可能对科研计算机和国防科工设备造成巨大损失。因此，现代行业中操作系统的安全性、稳定性和可靠性必不可少。

    常见操作系统内核主要分为几种，宏内核，微内核，混合内核，库操作系统，外核。
    Linux 操作系统就属于宏内核架构的，在这种架构中，所有的核心功能和服务都被运行在内核空间，不同的组件可以自由的相互调用，而不需要通过层次切换来实现核心功能间的沟通。
    但是由于其设计目的过于集中，缺乏对于第三方组件介入情况下系统的安全性和容错能力的保证，容易出现故障传播的问题。
    \cite{singh_microkernel_nodate}

    微内核将操作系统中能被剥离出来的部分剥离出来，最小化了内核提供的功能，内核提供了一组通用的机制(mechanisms)如进程调度，映射，通信等功能，由用户态程序实现实际的操作系统服务\footnote{如文件系统，设备驱动}，程序代码之间通过进程间通信(IPC) 机制与
    内核进行通信来获取系统中其他应用程序提供的服务。虽然这种内核可以降低各个模块之间的耦合，使系统容易拓展功能，但是由于其模块间通信的需求，
    进程间通信成本就成为了其架构相较于一般通用操作系统或者部分对时效性要求严格的操作系统最重要的缺陷。\footnote{还有不同特权级别之间的调用问题}
    \cite{hansen_nucleus_1970}

    而像是 Windows 操作系统就属于混合内核架构，这种架构结合了宏内核和微内核的优点，将常用组件放在内核态进行执行，保障了系统的高效性，也不会使系统的耦合程度过高导致难以拓展。

    而外核(ExoKernel) 不同于前两者，Engler 等通过一种名为 Secure Bingdings 的机制，其试图将安全性与抽象分离，其使操作系统的不可重写部分除了安全的多路复用硬件外几乎什么也不做
    ，以避免在应用程序上强制任何特定的抽象，而允许应用程序最大程度的释放其性能。
    这种方法是通过将操作系统抽象移动到 LibOS\footnote{LibOS是一种设计范式，在这种设计理念下操作系统的核心功能被封装成为一个库，与操作系统深度链接的应用程序可以通过对于这个库
    的调用实现操作系统级别的调用}
     这种不受信任的用户空间库中实现的，这些库通过链接的方式被应用程序调用。但是，Engler 等也指出了其内核的局限性，即应用程序与底层硬件
    高度契合会要求参与操作系统开发的程序员需要具备较高水平的技能和专业知识，且开发出的软件是专用的单一用途设备\footnote{在大多数情况下没有必要为了单一的硬件进行开发，
    因为开发结果难以复用，同时也会因为接口更改而需要频繁调整}，开发成本巨大。
    \cite{wikiosdev_exokernel, engler_exokernel_1998}

    不同于前者面临着需要在多种硬件设备上进行支持的困境，随着容器化技术的发展，Madhavapeddy 等基于容器化技术所构建的底层一致性平台提出了 Unikernel 这种专用的，单地址空间的操作系统，
    这种操作系统并没有如同前者一样将安全性与抽象一分为二的看，而是将二者结合在了一起，其通过模块化，专用化，使操作系统中的大部分组件是可以被便捷的复用、裁剪。又通过静态类型安全与单一
    地址空间构建了一种直接运行在虚拟机管理程序上的单一用途，密封的库操作系统\footnote{LibOS是一种设计范式，在这种设计理念下操作系统的核心功能被封装成为一个库，与操作系统深度链接的应用程序可以通过对于这个库
    的调用实现操作系统级别的调用} 虚拟机。
    在这个虚拟机上，所有的服务都是通过库的形式进行实现的，在应用程序编译的时候，所需求的库会与应用程序深度链接到一起
    \footnote{某种程度上讲，我觉得可以说得上参考了PORTER 等重构 Win7 过程中的经验，根据应用程序 API 进行提取相较于对于整个OS进行虚拟化降低了很大程度上的开支\cite{porter_rethinking_nodate}}
    ，而非一般操作时服务作为单独的程序被引入。
    而不必要的内部接口亦或是类似于 Shell 等功能均不作为默认进行而提供，降低了外界侵入所产生的危害与可能的攻击面，在实现程序紧凑
    \footnote{相较于一般的BIND DNS的Linux VM 镜像达到462MB，根据他们方法生成的Mirage设备生成的镜像大小只要183.5kB}
    的同时，实现了更大程度上的安全性保证。\cite{madhavapeddy_unikernels_nodate}

    在嵌入式领域中，KUENZER 等在他们的研究中提出了一种名为 Unikraft 的新型微库操作系统，这种操作系统提供了完全模块化的操作系统基元和一系列高性能 API（也是微库） 以方便用户对于操作系统进行定制。
    不同于前者必须通过 OCaml 函数式 进行开发，unikraft 通过其独特的编译、链接工具，实现了构建镜像过程中的静态链接，进而利用了编译器提供的死代码消除（Dead Code Elimination）与链接
    时间优化以消除没有被引用到的微库的代码。
    \cite{kuenzer_unikraft_2021}

    而随着 Rust 这种新型的，通过强制类型类型声明，所有权检查机制，生命周期检查器等一系列方式保障安全性的编程语言的出现，逐渐出现了一系列利用编程语言安全性优化的操作系统内核。
    LANKES 等在 2019 年的论文中首次提出使用 Rust 语言代替传统不安全的 C/CPP 程序语言开发操作系统，同时也利用其安全的内存模型和强大的类型系统提高系统的质量。
    他们在实验中重构了其基于 C 开发的 HermitCore，在构建 RustyHermit 的过程中，他们还证明了可以在 Rust 工具链中透明的集成其对于 Rusty Hermit 的支持，且二者性能相当。
    同时只有相当于 3.27\%左右的代码不能通过 Rust 编译器进行进行检查保障其安全性。
    \cite{lankes_exploring_2019, lankes_rustyhermit_2020}
    后来，(LANKES 等, 2020)尝试通过Rust语言重新实现了初版的 HermitCore（Rusty Hermit），
    结果表明Rust语言实现版本与C语言实现版本在性能方面没有明显差异。
    同时，得益于Rust独特的标记不安全代码的能力，操作系统中只有约3.27\%的代码需要特别关注安全性。

    % 基于类似于 (BOOS 等，2020) 提出的 Theseus 操作系统
    % NOTE: 似乎这边不太应该提到忒休斯，毕竟贡献其实都不算是一个方向的？
    % unikraft 和这位似乎可比性不太大（
    % 不过理念似乎是相通的？比如说链接成一个再检查什么的 ... 但是恢复可重建那部分就是特殊的贡献了
    % Matching the language’s runtime model only allows the compiler to view all Theseus components.
    % uses safe code to the fullest extent possible at all layers of the system, prioritizing safety over all else, e.g.

    陈渝团队开发了一种基于Rust安全性保障的新型操作系统ArceOS，将组件化和库操作系统相结合，在通过组件化提升操作系统可定制性的情况下
    保持尽可能大的独立性以方便用户以类似微内核的方式简话操作系统想法的开发与测试。使新的调度技术，内存管理技术，
    文件系统等尽可能做到一键替换现有的库（crates）以方便进行开发与测试。

    本次毕业设计主要是想要通过在这种不同于传统操作系统架构，如宏内核或者微内核的类 LibOS，Unikernel 架构下操作系统中实现一些简单嵌入式设备常见驱动的过程，为今后的学习打下坚实的基础，也同时为我国现代化操作系统的发展实现添加我的一份力量。

% \subsection{考虑整段去除}

% 出于成本考量进一步加剧。在功能复杂的操作系统，比如说 Linux 操作系统上运行轻量级服务会由于通用操作系统所进行的必要抽象
% 支付大量的开销(ANDERSON 等)(MASSALIN 等, 1989)。因此，找到某种方法以细粒度的定制操作系统是存在必要的。也因此 (ENGLER 等) 通过
% 一种名为 Secure Bingdings 的机制，将 LibOS 与其他用户库绑定在一起，允许应用程序以更加具体到硬件的方式对于底层硬件进行调用，
% 释放其性能而不受操作系统层面抽象的局限。但是这种实现方法由于机制内部会导致额外的上下文切换，同样会带来不必要的成本。
% \footnote{[ PESSÉ S, XIA Y, QIU L, 2015. 计算机系统原理讲义[EB/OL]//计算机系统原理（课程讲义）. (2015-07-21)[2023-12-06]. https://unitial.gitbooks.io/csp/content/index.html.]。
% }
% 同时，从底层硬件设备驱动的角度上来讲，一般这些设备只会针对于部分通用操作系统进行适配，由操作系统层面完成这类支持是没有效率的。

% 不过，由于云服务商对于不同环境中一致性和可移植性的需求，类似于 docker 这种容器化技术逐渐出现，(MADHAVAPEDDY 等) 基于容器技术或者
% 虚拟机管理程序提供的底层一致性平台上，提出了 Unikernel 这种专用的，单地址空间的使用库操作系统理念构造的组件化操作系统
% ，这种构建方式解决了如 ExoKernel 等操作系统所面临的，在底层硬件上的兼容性问题 ，提供了一个小型的，安全的，快速的工作负载。
% 同时，由于该操作系统在实现类似于一般操作系统的进程管理等功能外不提供额外如 Shell 等功能，
% 降低了由于外界侵入所产生的危害与攻击面，在实现了更大程度上的安全保障的同时，也使系统能够更加紧凑
% \footnote{相较于一般的BIND DNS的Linux VM 镜像达到462MB，根据他们方法生成的Mirage设备生成的镜像大小只要183.5kB
% （没有实现所有功能集，但是包含了queryperf测试套件的必要功能，且可用于自托管项目）的高度专业化单一用途设备虚拟机。 }
% ，根据用户需求进行客制化。


% (BOOS 等，2020) 的开发实践中通过其对 Rust 高等程序语言的编译编译工具链的利用实现了类似的效果，他们提出了一种名为 Theseus 的操作系统
% 这种操作系统通过减少一个组件为另一个组件保留的状态来重新设计和改进操作系统模块化，在尽可能的将保障内核安全的工作转嫁给 Rust 编译器
% 进行实现的基础上实现了对于核心操作系统组件的实时演化与故障恢复。不过，由于其代码特性，该操作系统实现的颗粒度相对更大,
% 不利于一般开发者参与进行开发。
% 贾越凯博士提出 ArceOS 的在其基础上粗放了对应核心组件的颗粒度，使得大部分的操作系统组件都可以以更加合乎一般操作系统开发者的开发
% 方式进行实现，在降低开发难度的同时，也实现了安全保障。


% (4)(PORTER 等) 在他们的研究中通过将广泛使用的单片操作系统(Windows 7)重构为一个功能丰富的库操作系统(Library OS)，
% 由一个小型抽象集（线程，虚存，I/O流）连接 Library OS 和 Host OS实现了独立于底层内核组件。
% 在早期的 Library OS 支持者中认为，通过个性化定制每一个应用程序，可以实现OS的较好性能，
% 但是现在Library OS已经成为了现代虚拟机监视器的牺牲品。 作者在本文中通过将每个Library OS的特性(应用程序依赖的) 共享底层的 
% Host OS 资源，这样在操作中，只需要根据应用程序的API进行提取，这样相较于虚拟化整个OS会大大的降低开销。
% % \footnote{\href{source}{https://blog.csdn.net/qq_40119224/article/details/118754160}}

\subsection{研究的主要工作}

    本研究主要的目的在于通过在一中不同于传统操作系统内核架构的组件化操作系统 ArceOS 上开发常见嵌入式项目。通过项目中对于操作系统与底层驱动的交互，深入了解嵌入式原理。

    其中主要实现的工作在于，通过对于指纹这种不易变更，不易转变使用者的生物识别特征对于小公司员工进行考勤打卡。其中当指纹传感器采集到数据，经过指纹模块分析，
    指标分析，微处理器转换，UDP 信息联网传输，上位机接收，返回认证包，进而通过蜂鸣声或者延时信号反馈识别成功信号提示用户打卡成功。
    同时，上位机还能基于下位机传输的信号进行简易的打卡记录查询等标准功能。

    其中主要的重难点在于对于 ArceOS 这样的一个非常规的操作系统使用到的各项驱动进行重写，如以太网驱动，指纹识别模块串口传输驱动。

\subsection{研究的预期目标}

    能够使同一网段下的嵌入式开发板与上位机之间进行相互通信。嵌入式段可以从 Client 端获取输入的指纹信息，在与指纹识别模块中信号进行对比后，由 UDP 网络包的形式向上位机进行发包，
    上位机收到对应信号之后，可以向下位机传输打卡成功信号以方便下位机向终端用户进行反馈。同时，由于一般打卡程序面临指纹增删改除的需求，还需要支持在上位机执行这些操作的功能。

\subsection{研究的创新点}
    
    尝试通过 ArceOS 这样的一种新颖的操作系统对于一个嵌入式应用场景中最常见的应用场景进行复刻，同时在实现过程中深入了解底层驱动实现原理，尽可能的做到将底层与操作系统设计勾连起来。

% \subsection{研究方法}

% 首先先简单完成电脑中有关于Rust等内容的开发环境配置，同时根据Nix生成一套可重构的开发环境框架，确保在后面的开发过程中整体开发过程是可复现的。
% 其次，深入了解现有的网卡驱动开发经验，并且了解其中所遇到的问题以及可能性的解决方案。在此基础上对于As608指纹识别模块驱动的现有实现进行了解，了解其中主要使用的数据结构等内容，以方便后面通过rust语言对于现有驱动进行重构。
% 然后，通过对于现有的指纹识别系统的分析，了解到目前常用的指纹识别框架。尝试了解no\_std情况下以及std情况下开发的差异。同时分析可能需要用到的库大概有多少是需要重新实现或者替换库的。
% 通过ArceOS现有的工作完成网络联网测试，实现几个简单的用户程序，首先确保能在多台华山派CV1811H甚至支持更少功能的嵌入式设备上运行简单发包程序并且联网成功。根据已有驱动尝试在ArceOS上进行测试等开发工作，最终将指纹识别驱动以及可能会用到的显示屏驱动，装载上进行整机测试。

